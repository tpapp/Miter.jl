var documenterSearchIndex = {"docs":
[{"location":"#Miter","page":"Miter","title":"Miter","text":"At the moment, this package is work in progress. The syntax may change without notice, and a lot of the functionality is undocumented. More importantly, an explanation of the key concepts that help in using this package is yet to be written.","category":"section"},{"location":"#Introduction","page":"Miter","title":"Introduction","text":"TBW","category":"section"},{"location":"#String-like-arguments","page":"Miter","title":"String-like arguments","text":"Strings (for axis labels, annotations, plot titles) can be provided three ways:\n\nusing any ::AbstractString (except for the types below), eg \"100%\" or \"$5\". This will be automatically emitted to the \\LaTeX engine in an escaped form, such as 100\\%or \\$5. Use this for plain text (including Unicode). This is always valid.\nusing the [LaTeXEscapes.LaTeX]@ref) wrapper that emits strunchanged, or one of the convenience string literals lx\"...\"or lx\"...\"m, where the only difference is that the latter wraps the content in $s (for math). Be careful: some basic sanity checks are performed, but using incorrect raw LaTeX can lead to errors that are hard to trace.\nusing LaTeXString.LaTeXString, especially if you want interpolation, but note that L\"...\" automatically wraps its input in $s and you may not want that.\n\nIf you concatenate strings of the types above with the * operator, make sure you put a LaTeX first (you can always insert an empty one, eg LaTeX() or lx\"\". That way, the output is a LaTeX and everything will be correctly escaped. Other combinations are deliberately unsupported.","category":"section"},{"location":"#Coordinates-and-bounds","page":"Miter","title":"Coordinates and bounds","text":"A plot is rendered in the following manner:\n\nThe coordinate bound is determined using all elements.\nAxes are set up based on the calculated bounds.\n\nThe bounds of a plot element are determined using Miter.combine_bounds_xy. The default uses Miter.bounds_xy and combines the result, special cases can be handled by using something other than combination. Plot elements need to be in containers which are iterable for deterministic results.\n\nIndividual coordinate bounds are determined using Miter.Coordinates.coordinate_bounds_xy. The default calls extrema on the first and second element of coordinates. Other coordinate formats should customize this function.","category":"section"},{"location":"#Gallery","page":"Miter","title":"Gallery","text":"What you see below is a gallery of plots. These serve as examples, and are also useful for visual inspection of plots.\n\nAll should be preceded by\n\nusing Miter, Colors\nusing LaTeXEscapes\nusing Unitful: mm\n\nto load the relevant packages.","category":"section"},{"location":"#Simple-plots","page":"Miter","title":"Simple plots","text":"Plot([Lines((x, abs2(x)) for x in -1:0.02:1; color = colorant\"red\"),\n      Scatter(MarkSymbol(; color = colorant\"darkgreen\"), (x, (x + 1) / 2) for x in -1:0.1:1)];\n      x_axis = Axis.Linear(; label = lx\"x\"m),\n      y_axis = Axis.Linear(; label = lx\"y\"m),\n      title = \"line and scatter\")\n\nHorizontal and vertical lines, and phantom objects (rendered, but ignored for boundary calculations).\n\nPlot(Scatter((x, sin(x) + (rand() - 0.5) / 10) for x in range(-π, π; length = 100)),\n     Phantom(Hline(12.0)),      # does not show, it is outside the boundaries\n     Hline(0.0), Vline(0.0))\n\nBar plots with bars directly specified.\n\nlet c = [(0, 1, 2), (1, 2, 1), (2, 4, -0.5)]\n    Tableau([Plot(RelativeBars(:vertical, c)),\n             Plot(RelativeBars(:horizontal, c))])\nend\n\nBar plots from a histogram.\n\nusing StatsBase\nPlot(RelativeBars(:vertical, fit(Histogram, randn(100))))\n\nAnnotations.\n\nlet c = colorant\"teal\",\n    xy = collect((x,  0.5 * x + 0.1 * randn()) for x in range(-1, 1; length = 30))\n    Plot(Scatter(MarkSymbol(; color = c), xy),\n         Annotation((0, 0.3), textcolor(c, lx\"random dots $y = 0.5\\cdot x + N(0, 0.1)$\");\n                    rotate = 30))\nend\n\nVarious kinds of marks.\n\nlet x = range(0, 1; length = 21)\n    Plot(Scatter(MarkSymbol(:+; color = colorant\"firebrick\"), (x, 0.2 * x) for x in x),\n         Scatter(MarkSymbol(:*, color = colorant\"olive\"), (x, 0.1 + abs2(x)) for x in x),\n         Scatter(MarkSymbol(:o; color = colorant\"teal\"), (x, -x + abs2(x) - 0.1) for x in x))\nend\n\nGuidelines, adding plot elements (with push! & friends).\n\nlet plot = Plot(Scatter(MarkSymbol(:o; color = colorant\"chocolate4\"),\n                        (sin(α), cos(α)) for α in range(-π, π, length = 61)))\n    for θ in 0:30:150\n        pushfirst!(plot.contents, LineThrough((0, 0), tand(θ)))\n    end\n    plot\nend\n\nGrids.\n\nPlot(Hgrid(), Vgrid(), # specified first; renders first\n     Scatter((x, expm1(x) + randn() / 10)\n             for x in range(0, 1; length = 100)))\n\nSync x and y bounds in a tableau.\n\nusing Accessors # for @modify\n\nfunction wobbler(x, y, r, rotate)\n    Plot(Lines([sincos(θ) .* (r * (sin(θ  * 3 + rotate)/4 + 1))\n                for θ in range(0, 2*π; length = 200)]))\nend\n\nm = Tableau(balanced_matrix([wobbler(0, 0, 2, 0),\n                                wobbler(1, 0, 1, π/2),\n                                wobbler(-1, 0, 3, -π/2),\n                                wobbler(1, 3, 1, π)]));\n@modify(sync_bounds(:xy), m.contents) # sync columns and rows\n\nAdd bounds to extend the y axis.\n\nPlot([Lines((x, x^2) for x in range(0, 1; length = 20)),\n      JustBounds(nothing, Interval(-1, 1))])\n\nQ5 (five quantiles) plots.\n\nPlot(Scatter(MarkQ5(),\n             (x, Q5(randn(10) ./ 4 .+ (x / 3)))\n             for x in range(0, 5; length = 8)),\n     Scatter(MarkQ5(; color = colorant\"deepskyblue1\"),\n             (Q5(randn(10) ./ 4 .+ (abs2(y) / 5)), y)\n             for y in range(0, 5; length = 8)))\n\nCircles.\n\nx_y_w = [(x, y, 6 - hypot(x, y)) for x in -5:5 for y in -5:5 if hypot(x, y) ≤ 5]\n# make the largest point have 3mm radius\nPlot(Circles(x_y_w, 3mm / √maximum(last, x_y_w)))\n\nColor matrix (a building block for heatmaps etc).\n\nPlot(ColorMatrix([0, 1, 3], [2, 4, 5],\n                 [nothing colorant\"green\";\n                  colorant\"blue\" colorant\"red\"]))\n\nColor matrix built from a histogram.\n\nusing StatsBase, ColorSchemes\nh = fit(Histogram, (randn(1000), randn(1000)); nbins = (15, 17))\nPlot(hpd_heatmap(h, range(0.2, 0.8; step = 0.2), ColorSchemes.OrRd_5))","category":"section"},{"location":"#Tableaus","page":"Miter","title":"Tableaus","text":"Tableau(balanced_matrix(\n        [Plot(Lines([(x, exp(-0.5 * abs2(x)) / √(2π))\n                     for x in range(-2, 2; length = 101)]);\n              y_axis = Axis.Linear(; label = \"pdf of normal distribution\")),\n         Plot(Lines([(x, exp(-abs(x)) / 2)\n                     for x in range(-2, 2; length = 101)]);\n              y_axis = Axis.Linear(; label = \"pdf of Laplace distribution\")),\n         Plot(Lines([(x, exp(-x))\n                     for x in range(0.1, 2; length = 50)]);\n              y_axis = Axis.Linear(; label = \"pdf of exponential distribution\"))]))","category":"section"},{"location":"#Visual-debugging","page":"Miter","title":"Visual debugging","text":"Canvas(Tableau([Miter.dummy(\"$(x), $(y)\") for x in 1:3, y in 1:4]),\n       width = 100mm, height = 100mm)","category":"section"},{"location":"#Contour-plots","page":"Miter","title":"Contour plots","text":"The package Contour.jl is easy to interface with directly.\n\nusing Contour, Miter\nx = range(-1, 1; length = 100)\nz = [(θ = atan(y, x); (0.6 * abs(θ)^0.5) / (0.2 * x^2 + y^2)^(1/3)) for x in x, y in x]\nc = contours(x, x, z)\nPlot(mapreduce(l -> [Lines(vertices(l)) for l in lines(l)], vcat, levels(c)))","category":"section"},{"location":"#Corner-cases","page":"Miter","title":"Corner cases","text":"","category":"section"},{"location":"#Handle-collapsing-axes-gracefully","page":"Miter","title":"Handle collapsing axes gracefully","text":"Plot(Scatter([(0.49999,0.49999)]))","category":"section"}]
}

"""
The drawing backend.

Plots and their elements are drawn using `render`, which they should implement. Inside
those methods, they emit commands to a `sink`.
"""
module Draw

# reexported as API
export textcolor, save, Canvas

using ArgCheck: @argcheck
using ColorTypes: Colorant, red, green, blue
using DocStringExtensions: FUNCTIONNAME, SIGNATURES
using LaTeXCompilers: pdf, png, svg
using Printf: @printf

using ..Lengths: mm, pt, Length
using ..InternalUtilities
using ..DrawTypes
using LaTeXEscapes: print_escaped, @lx_str
using ..Styles: DEFAULTS

####
#### sink interface
####

Base.@kwdef mutable struct Sink{T}
    io::T
    "last line width set"
    line_width::Union{Nothing,Length} = nothing
    "last stroke color set"
    stroke_color::Union{Nothing,COLOR} = nothing
    "last fill color set"
    fill_color::Union{Nothing,COLOR} = nothing
    "last dash set"
    dash::Union{Nothing,Dash} = nothing
end

"""
$(SIGNATURES)

Reset the state that the sink remembers.
"""
function reset!(sink::Sink)
    sink.line_width = nothing
    sink.stroke_color = nothing
    sink.fill_color = nothing
    sink.dash = nothing
end

"""
$(SIGNATURES)

Wrap an `io` in a `Sink` for outputting PGF primitives.

A `Sink` records various drawing properties, so it can omit superfluous set commands.
"""
sink(io::IO) = Sink(; io = io)

####
#### rendering
####

"""
$(SIGNATURES)

Render `object` within `context` (a [`Rectangle`](@ref), or similar) using `sink`.

Rendering `nothing` is a no-op.
"""
render(sink::Sink, rectangle::Rectangle, object::Nothing) = nothing

"""
$(SIGNATURES)

The preamble that should precede output generated by this module to compile in LaTeX. Cf
[`postamble`](@ref). When `standalone = true`, the document setup is skipped.

`bounding_box` is a rectangle that determines the bounding box, with the given `baseline` (converted to `mm` if necesary).

After the preamble, bounding box calculations are suspended.
"""
function preamble(sink::Sink, bounding_box::Rectangle;
                  standalone::Bool, baseline::Length = 0mm)
    standalone || _print(sink, raw"""
\documentclass{standalone}
\usepackage{pgfcore}
\begin{document}
""")
    _print(sink, raw"""
\begin{pgfpicture}
""")
    Draw.path(sink, bounding_box)
    _println(sink, raw"\pgfusepath{use as bounding box}",
           raw"\pgfsetbaseline{", baseline, "}\n",
           raw"\begin{pgfinterruptboundingbox}")
end

"""
$(SIGNATURES)
"""
function postamble(sink::Sink; standalone::Bool)
    _print(sink, raw"""
\end{pgfinterruptboundingbox}
\end{pgfpicture}
""")
    standalone || _print(sink, raw"""
\end{document}
""")
end

struct Canvas
    content::Any
    width::Length
    height::Length
    @doc """
    $(SIGNATURES)

    A wrapper for rendering `content` with the given `width` and `height`.
    """
    function Canvas(content; width = DEFAULTS.canvas_width, height = DEFAULTS.canvas_height)
        new(content, width, height)
    end
end

function print_tex(sink::Draw.Sink, canvas::Canvas; standalone::Bool = false)
    (; content, width, height) = canvas
    _canvas = Rectangle(; left = 0mm, right = width, bottom = 0mm, top = height)
    Draw.preamble(sink, _canvas; standalone)
    Draw.render(sink, _canvas, content)
    Draw.postamble(sink; standalone)
end

function print_tex(io::IO, object::Canvas; standalone = false)
    print_tex(Draw.sink(io), object; standalone)
end

function print_tex(filename::AbstractString, object::Canvas; standalone::Bool = false)
    open(filename, "w") do io
        print_tex(io, object; standalone)
    end
end

"""
$(SIGNATURES)

Wrap the input in a `Canvas`. Should be available for types that [`declare_showable`](@ref).
"""
wrap_in_default_canvas(canvas::Canvas) = canvas

"""
$(SIGNATURES)

Helper function to render `object` to `svg_io`.
"""
function _show_as_svg(svg_io::IO, object)
    svg(io -> print_tex(io, wrap_in_default_canvas(object)), svg_io)
end

"""
$(SIGNATURES)

Define a graphical `Base.show` method for type `T`.
"""
macro declare_showable(T)
    :(Base.show(io::IO, ::MIME"image/svg+xml", object::$(esc(T))) = _show_as_svg(io, object))
end

@declare_showable Canvas

####
#### generating TeX output
####

"""
$(SIGNATURES)

Save `object` into `filename`.

File type is determined by its extension, which can be overidden by `ext` (a string, case
does not matter as it is normalized). Valid options are:

- `pdf`: Portable Document Format (PDF)
- `svg`: Scalable Vector Graphics (SVG)
- `png`: Portable Network Graphics (PNG)
- `tex`: standalone LaTeX code that can be compiled *as is*
- `tikz`: LaTeX code that can be included in a document

For tex/tikz, the LaTeX package `pgf` needs to be available/included in the document.
"""
function save(filename::AbstractString, object; ext = lstrip(splitext(filename)[2], '.'))
    ext = splitext(filename)[2]
    _print_tex = Base.Fix2(print_tex, wrap_in_default_canvas(object))
    ext = lowercase(ext)
    if ext == ".pdf"
        pdf(_print_tex, filename)
    elseif ext == ".svg"
        svg(_print_tex, filename)
    elseif ext == ".png"
        png(_print_tex, filename)
    elseif ext == ".tex"
        open(_print_tex, filename, "w")
    elseif ext == ".tikz"
        open(io -> print_tex(io, object; standalone = true), filename, "w")
    elseif ext == ""
        error("could not determine file type without extension, specify it explicitly")
    else
        error("don't know to handle extension $(ext)")
    end
end

####
#### utilities for writing LaTeX
####

"""
$(SIGNATURES)

Write the PGF/LaTeX representation to `sink`. Not exposed outside this module.

Methods are encouraged to define `_print(sink::Sink, x::T)` for types `T` which can be
directly printed for processing by LaTeX (eg numbers, lengths, colors, etc).

Printing raw strings and objects to a `sink` should only be done by this method.
"""
_print(sink::Sink, xs...) = foreach(x -> _print(sink, x), xs)

_println(sink::Sink, xs...) = (foreach(x -> _print(sink, x), xs); _print(sink, '\n'))

_print(sink::Sink, x::Union{AbstractString,AbstractChar,Int,Float64}) = print(sink.io, x)

_print(sink::Sink, x::Length) = @printf(sink.io, "%fpt", x / pt)

function _print(sink::Sink, color::COLOR)
    _print(sink, "rgb,1:red,", Float64(red(color)),
           ";green,", Float64(green(color)),
           ";blue,", Float64(blue(color)))
end

####
#### simple commands
####

"""
$(SIGNATURES)

Translate a symbol to a pgf command name string.
"""
_pgfcommand(s::Symbol) = "\\pgf" * string(s)

function setfillcolor(sink::Sink, color::COLOR)
    if sink.fill_color ≠ color
        sink.fill_color = color
        _println(sink, raw"\pgfsetfillcolor{", color, "}")
    end
end

setfillcolor(sink::Sink, color::Colorant) = setfillcolor(sink, COLOR(color))

function setstrokecolor(sink::Sink, color::COLOR)
    if sink.stroke_color ≠ color
        sink.stroke_color = color
        _println(sink, raw"\pgfsetstrokecolor{", color, "}")
    end
end

setstrokecolor(sink::Sink, color::Colorant) = setstrokecolor(sink, COLOR(color))

function setcolor(sink::Sink, color::COLOR)
    if !(sink.stroke_color == color == sink.fill_color)
        sink.fill_color = color
        sink.stroke_color = color
        _println(sink, raw"\pgfsetcolor{", color, "}")
    end
end

setcolor(sink::Sink, color::Colorant) = setcolor(sink, COLOR(color))

"""
$(SIGNATURES)

Set line width, converting to `mm` if necessary.
"""
function setlinewidth(sink::Sink, line_width::Length)
    if sink.line_width ≠ line_width
        sink.line_width = line_width
        _print(sink, raw"\pgfsetlinewidth{", line_width, "}")
    end
end

####
#### points
####

function _print(sink::Sink, point::Point)
    (; x, y) = point
    _print(sink, raw"\pgfqpoint{", x, "}{", y, "}")
end

###
### path manipulation
###

function pathmoveto(sink::Sink, point::Point)
    _println(sink, raw"\pgfpathmoveto{", point, "}")
end

function pathlineto(sink::Sink, point::Point)
    _println(sink, raw"\pgfpathlineto{", point, "}")
end

function pathcircle(sink::Sink, point::Point, radius::Length)
    _println(sink, raw"\pgfpathcircle{", point, "}{", radius, "}")
end

# commands without arguments
for command in (:pathclose, :usepathqfill, :usepathqstroke, :usepathqfillstroke,
                :usepathqclip)
    @eval function $command(sink::Sink)
        _println(sink, $(_pgfcommand(command)))
    end
end

function path(sink::Sink, rectangle::Rectangle)
    (; left, right, bottom, top) = rectangle
    _println(sink, raw"\pgfpathrectanglecorners{",
                Point(left, bottom), "}{", Point(right, top), "}")
end

function usepath(sink::Sink, actions...)
    had_fill = false
    had_stroke = false
    had_clip = false
    is_first = true
    _print(sink, raw"\pgfusepath{")
    for action in actions
        if is_first
            is_first = false
        else
            _print(sink, ',')
        end
        if action ≡ :fill
            @argcheck !had_fill "Duplicate `:fill`."
            _print(sink, "fill")
            had_fill = true
        elseif action ≡ :stroke
            @argcheck !had_stroke "Duplicate `:stroke`."
            _print(sink, "stroke")
            had_stroke = true
        elseif action ≡ :clip
            @argcheck !had_clip "Duplicate `:clip`."
            _print(sink, "clip")
            had_clip = true
        elseif action ≡ :discard
            @argcheck(had_fill == had_stroke == had_clip == false,
                      "Can't use `:discard` with other actions.")
            # NOTE: we don't print "discard", empty list has same effect
            break
        else
            throw(ArgumentError("Unknown action $(action)."))
        end
    end
    _print(sink, "}\n")
end

###
### scope
###

begin_scope(sink::Sink) = _print(sink, "\\begin{pgfscope}")

end_scope(sink::Sink) = (_print(sink, "\\end{pgfscope}"); reset!(sink))

function with_scope(f, sink::Sink)
    begin_scope(sink)
    f()
    end_scope(sink)
end


###
### text
###

"""
$(SIGNATURES)

Check alignment args of `Draw.text`, provide a sensible error message.
"""
function _check_text_alignment(; top, bottom, base, left, right)
    @argcheck top + bottom + base ≤ 1
    @argcheck left + right ≤ 1
end

"""
$(SIGNATURES)

Text output.

`str` can be anything that `LaTeXEscapes.print_escaped` handles, including
`AbstractString`, `LaTeXEscapes.LaTeX`, and `LaTeXStrings.LaTeXString`.
"""
function text(sink::Sink, at::Point, str;
              left::Bool = false, right::Bool = false,
              top::Bool = false, bottom::Bool = false, base::Bool = false,
              rotate = 0)
    _check_text_alignment(; top, bottom, base, left, right)
    (; x, y) = at
    _print(sink, raw"\pgftext[x=", x, ",y=", y)
    left && _print(sink, ",left")
    right && _print(sink, ",right")
    top && _print(sink, ",top")
    bottom && _print(sink, ",bottom")
    base && _print(sink, ",base")
    iszero(rotate) || _print(sink, ",rotate=", rotate)
    _print(sink, "]{")
    print_escaped(sink.io, str; check = true)
    _println(sink, "}")
end

"""
$(SIGNATURES)

Wrap text (`LaTeX`, or plain text) in the LaTeX command that makes it have the given `color`.
"""
function textcolor(color::COLOR, text)
    (lx"\textcolor[rgb]{" *
        Float64(red(color)) * "," * Float64(green(color)) * "," * Float64(blue(color)) *
        lx"}{" * text * lx"}")
end

textcolor(color::Colorant, text) = textcolor(COLOR(color), text)


####
#### utilities
####

"""
$(SIGNATURES)

Path and stroke a line segment between two points. Caller sets everything else before.
"""
function segment(sink::Sink, a::Point, b::Point)
    pathmoveto(sink, a)
    pathlineto(sink, b)
    usepathqstroke(sink)
end

"""
$(SIGNATURES)

Helper function to set line style parameters (when `≢ nothing`).
"""
function set_line_style(sink::Draw.Sink; color = nothing, width = nothing, dash = nothing)
    color ≢ nothing && Draw.setstrokecolor(sink, color)
    width ≢ nothing && Draw.setlinewidth(sink, width)
    dash ≢ nothing && Draw.setdash(sink, dash)
end

"""
$(SIGNATURES)

A utility function to

1. set the stroke color when not `nothing`, and then also the line width,
2. set the fill color when not `nothing

For use by callers where the user specifies at least one of these. See also
[`path_q_stroke_or_fill`](@ref).
"""
function set_stroke_or_fill_style(sink::Draw.Sink; stroke_color, fill_color, stroke_width)
    if stroke_color ≡ nothing && fill_color ≡ nothing
        error(ArgumentError("you need to set at least one stroke or fill color"))
    end
    if stroke_color ≢ nothing
        set_line_style(sink; color = stroke_color, width = stroke_width)
    end
    if fill_color ≢ nothing
        Draw.setfillcolor(sink, fill_color)
    end
end

"""
$(SIGNATURES)

Quick stroke or fill whenever the respective color is not `nothing`.
"""
function path_q_stroke_or_fill(sink, stroke_color, fill_color)
    if stroke_color ≡ nothing && fill_color ≡ nothing
        error(ArgumentError("you need to set at least one stroke or fill color"))
    elseif stroke_color ≢ nothing && fill_color ≢ nothing
        Draw.usepathqfillstroke(sink)
    elseif stroke_color ≢ nothing
        Draw.usepathqstroke(sink)
    else fill_color ≢ nothing
        Draw.usepathqfill(sink)
    end
end

####
#### marks
####

function setdash(sink::Sink, dash::Dash)
    if sink.dash ≠ dash
        sink.dash = dash
        (; dimensions, offset) = dash
        _print(sink, raw"\pgfsetdash{")
        for d in dimensions
            _print(sink, '{', d, '}')
        end
        _print(sink, "}{", offset, "}")
    end
end

end
